# -*- coding: utf-8 -*-
"""assignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vfUnQr1mtxENFHThTF-HY7wgRX7zY5KS

# Assignment 1 - Creating and Manipulating Graphs

Eight employees at a small company were asked to choose 3 movies that they would most enjoy watching for the upcoming company movie night. These choices are stored in the file `assets/Employee_Movie_Choices.txt`.

A second file, `assets/Employee_Relationships.txt`, has data on the relationships between different coworkers.

The relationship score has value of `-100` (Enemies) to `+100` (Best Friends). A value of zero means the two employees haven't interacted or are indifferent.

Both files are tab delimited.
"""

import networkx as nx
import pandas as pd
import numpy as np


# This is the set of employees
employees = set(['Pablo',
                 'Lee',
                 'Georgia',
                 'Vincent',
                 'Andy',
                 'Frida',
                 'Joan',
                 'Claude'])

# This is the set of movies
movies = set(['The Shawshank Redemption',
              'Forrest Gump',
              'The Matrix',
              'Anaconda',
              'The Social Network',
              'The Godfather',
              'Monty Python and the Holy Grail',
              'Snakes on a Plane',
              'Kung Fu Panda',
              'The Dark Knight',
              'Mean Girls'])


# you can use the following function to plot graphs
# make sure to comment it out before submitting to the autograder
def plot_graph(G, weight_name=None):
    '''
    G: a networkx G
    weight_name: name of the attribute for plotting edge weights (if G is weighted)
    '''
    #%matplotlib notebook
    import matplotlib.pyplot as plt

    plt.figure()
    pos = nx.spring_layout(G)
    edges = G.edges()
    weights = None

    if weight_name:
        weights = [int(G[u][v][weight_name]) for u,v in edges]
        labels = nx.get_edge_attributes(G,weight_name)
        nx.draw_networkx_edge_labels(G,pos,edge_labels=labels)
        nx.draw_networkx(G, pos, width=weights);
    else:
        nx.draw_networkx(G, pos,);

"""### Question 1

Using NetworkX, load in the bipartite graph from `assets/Employee_Movie_Choices.txt` and return that graph.

*This function should return a bipartite networkx graph with 19 nodes and 24 edges*
"""

def answer_one():


    # Load the data
    df = pd.read_csv('assets/Employee_Movie_Choices.txt', delimiter='\t')

    # Create an empty graph
    B = nx.Graph()

    # Add edges from employee to movie
    for idx, row in df.iterrows():
        B.add_edge(row['#Employee'], row['Movie'])

    return B

G1 = answer_one()
print(len(G1.nodes()))
print(len(G1.edges()))

import matplotlib.pyplot as plt
# Show the graph
plot_graph(G1)
plt.savefig("employee_movie_graph.png")

assert type(answer_one()) == nx.Graph , "Your return type should be a Graph object"

"""### Question 2

Using the graph from the previous question, add nodes attributes named `'type'` where movies have the value `'movie'` and employees have the value `'employee'` and return that graph.

*This function should return a bipartite networkx graph with node attributes `{'type': 'movie'}` or `{'type': 'employee'}`*
"""

def answer_two():
    G = answer_one()

    for node in G.nodes():
        if node in employees:
            G.nodes[node]['type'] = 'employee'
        else:
            G.nodes[node]['type'] = 'movie'

    return G

assert type(answer_two()) == nx.Graph , "Your return type should be a Graph object"

G2 = answer_two()
print(G2.nodes(data=True))

"""### Question 3

Find a weighted projection of the graph from `answer_two` which tells us how many movies different pairs of employees have in common.

*This function should return a weighted projected graph.*
"""

def answer_three():
    G = answer_two()

    # Get only the employee nodes
    employee_nodes = {n for n, d in G.nodes(data=True) if d['type'] == 'employee'}

    # Create the weighted projection
    proj = nx.bipartite.weighted_projected_graph(G, employee_nodes)

    return proj

G = answer_three()
plot_graph(G, weight_name="weight")
G.edges(data = True)

import matplotlib.pyplot as plt
plot_graph(G, weight_name="weight")
plt.savefig("projected_graph.png")

assert type(answer_three()) == nx.Graph , "Your return type should be a Graph object"

"""### Question 4

Suppose you'd like to find out if people that have a high relationship score also like the same types of movies.

Find the pearson correlation between employee relationship scores and the number of movies they have in common. If two employees have no movies in common it should be treated as a 0, not a missing value, and should be included in the correlation calculation.

*This function should return a float.*
"""

def answer_four():
    import pandas as pd
    import numpy as np

    # Load relationships with custom column names
    rel_df = pd.read_csv(
        'assets/Employee_Relationships.txt',
        delimiter='\t',
        header=None,
        names=['Employee1', 'Employee2', 'Relationship']
    )

    # Get the projected graph from Q3
    G_proj = answer_three()

    # Prepare lists for correlation
    relationship_scores = []
    movie_overlap = []

    # Loop through each pair
    for idx, row in rel_df.iterrows():
        emp1 = row['Employee1']
        emp2 = row['Employee2']
        rel_score = row['Relationship']

        # Check if they have movies in common
        if G_proj.has_edge(emp1, emp2):
            weight = G_proj[emp1][emp2]['weight']
        else:
            weight = 0

        relationship_scores.append(rel_score)
        movie_overlap.append(weight)

    # Compute Pearson correlation
    corr = np.corrcoef(relationship_scores, movie_overlap)[0, 1]

    return corr

ans_four = answer_four()

ans_four = answer_four()
print(ans_four)

